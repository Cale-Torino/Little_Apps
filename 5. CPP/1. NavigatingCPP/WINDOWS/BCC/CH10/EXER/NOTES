
												Exercises

	1. Modify the program that uses apply() to accept template function
		arguments.

		Solution:  Look at ptf3.c. Because someone has to instantiate a
		type, we overload apply() and specialize for Strings and integers.
		The tradeoff here is which is more important:  a template apply()
		or a template add() and sub().

	2. Enhance the array class hierarchy so the Basic Rule applies.

							a[i] = (*(a + i))

		Suppose you have array declarations as follows.

		Array<int> a(5);
		Array2d<int> b(5, 10);
		Array3d<int> c(5, 10, 20);

		Make your modified classes accept all of the following expressions.

		*(a + i)
		*(b[i] + j) 
		*(*(b + i) + j) 
		*(c[i][j] + k) 
		*(*(c[i] + j) + k) 
		*(*(*(c + i) + j) + k) 

		Solution:  Overload operator+() and operator-() in the array classes
		to accept an Array lhs and an integer rhs.  Have each routine just
		return the private state variable pointer in each class.

		Also, should we overload unary operator*()? This would allow
		expressions like

		*a			**b			**c

		which are all legal with built-in arrays.
		(I think we should.)

	3. Replace the Array class in Fifo with the List class from the chapter.
		How Does this change in containment affect the rest of the Fifo design?

		Answer:
		In the code, write() calls List::append() and read() calls List::remove().
		The full() method goes away, since a Fifo can never be full.
		You still do not need the full boilerplate.

	4. Operator new does not support a syntax to create an array of types and
	   initialize each array element to a specific value.
		Consider the following template function that performs this operation.

		  template <class TYPE>
		  TYPE* anew(int len, TYPE ivalue) {
			  TYPE *p = new TYPE[len];
			  if (p == 0)
				  throw "no free store memory";
			  for (int i = 0; i < len; i++)
				  p[i] = ivalue;
			  return p;
		  }

		  int *p = anew(10, 8);						// array of 10 integers, all 8
		  String *q =anew(10, String("abc"));	// array of 10 Strings, all "abc"
		  delete [] p;									// deallocate integer array
		  delete [] q;									// deallocate String array

		How efficient is this template function (say, for String objects)?
		What could you do to make this template function perform better?
		What are the tradeoffs for such a design change?

		Hint:  Modify anew() to crate a pointer array and initialize each element
				 with a copy initializor.

	 	Solution:   Look at anew2.c. 
						Here are the tradeoffs.

							1. The user must delete free store or there will be
							 	memory leaks.  Note that the user must do TWO deletes.

						   2. The user must keep track of the size, which is an
								error prone requirement.

						   3. Applications must use *a[i] notation to access array
								elements.

	 	Suggestion:  You could make adelete simpler and omit the length 
						 requirement if you allocated free store and placed the size
						 IN FRONT of the pointer (like Borland does).  This makes
						 pgms simply call anew() as follows.

						  int **p = anew(10, 8);
						  String **q =anew(10, String("abc"));
						  adelete(p);
						  adelete(q);

	5. Redesign the String class from Chapter 3 to be a fixed length template
		class.

		FString a;
		FString b<255>;
		Fstring c<80> = "this is a string";

		How does a fixed length design affect the boilerplate?
		What are the tradeoffs between each approach?

	6. Modify the array class hierarchy to use the same approach the Block
		class uses for memory management.  How does this affect performance?
		What are the tradeoffs between approaches?

		Solution:  Look at array.h and array.c.  These are the only changes.
		Note that we use a pointer to a pointer to the data, so two ** are
		necessary in operator[] (this slows you down).  In copy(), however,
		we avoid operator=() in most classes.
		The constructors and destructor have to change, too, since they must
		create/destory pointer arrays and as well as the data.

		The bottom line is that this modification probably slows down the 
		array classes, since you spend most of your time in a[i], not with
		copies and construction.
