
                              Exercise 6

Actually, both cardID and a person's full name should not be strings
when implementation gets under way. We find it helpful to take a
quick, best guess at an attribute type. Further refinements and
iterations frequently change and improve attribute designs.

If we make CardID its own type (class), then we can control its
values more easily.

   class CardID {
   private:
      const String idString;
      static String next_id;
      static void set_next()             // "increment" next_id
      {}
   public:
      CardID() : idString(next_id) { set_next(); }
      String getId() const { return idString; }
   };

Also, a person's full name will probably be two or more strings, as follows:

   class FullName {
   private:
      const String lastname;
      const String firstname;
      const String middle;
   public:
      FullName(const String & last, const String & first = "", 
         const String & m = "") : lastname(last), firstname(first), 
            middle(m) { }
      String get_lastname() const { return lastname; }
      String get_firstname() const { return firstname; }
      String get_middle() const { return middle; }
   };

Now, a search() routine for a LibraryMember by either CardID or FullName
becomes a simple matter of overloading. Because CardID and FullName
are distinct types, no mixups or ambiguities occur.

   class Catalog_of_LibraryMembers {
    . . .
   public:
      LibraryMember *search(const FullName & fn) const;
      LibraryMember *search(const CardID & cardid) const;
   };
